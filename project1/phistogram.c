/*
 *
 * ######################################################
 * Date: 22/10/2018
 * @Author: Aldo Tali 21500097
 * Description: Solution to the first project given
 * in Cs342 Operating Systems Fall 2018-2019.
 * ######################################################
 *
 * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h> 
#include <unistd.h> 
#include <sys/types.h>
#include <sys/wait.h> 
#include <sys/time.h>
#include <time.h> 

void childOperation(double minvalue, double maxvalue, char *outfile, char* readfile, int bincount);
void initializeArray (int *array, int size, int initializer);
void getHistogram (FILE *file, int *histogram, double minvalue,double maxvalue, double width);
int getIndex(double start, double end,  double width, double no);
void writeHistogramToFile(FILE *file, int *histogram, int sizei,int intermediate);
void mergeHistograms ( int bincount,int N, FILE *outfile);
int mainSimulator(int argc, char*argv[]);

int main(int argc, char*argv[])
{
    struct timeval start, end; 
    gettimeofday(&start, NULL);
    mainSimulator(argc,argv);
    gettimeofday(&end, NULL);
    double elapsed = (end.tv_sec - start.tv_sec) + 
              ((end.tv_usec - start.tv_usec)/1000000.0);
    printf("The elapsed time is: %f\n", elapsed);

    return(0);
}

int mainSimulator(int argc, char*argv[]){
     //prompt user if he does not enter the right number of arguments
    //user input is of the following format:
    //phistogram minvalue maxvalue bincount N file1 ... fileN outfile
    //Assuming the very least case N = 1 then we need 6 or more arguments
    if (argc < 7)
    {
        printf("Please enter the correct input information.\n");
        printf("It has the follow the follwoing format: \n ");
        printf("phistogram minvalue maxvalue bincount N file1 ... fileN outfile\n\n");
        exit(1);
    }

    //define the numbers gotten from the input
    double minvalue,maxvalue,width;
    int     bincount,N,i;

    //put the arguments in the variables for ease of use
    sscanf(argv[1],"%lf",&minvalue);
    sscanf(argv[2],"%lf",&maxvalue);
    sscanf(argv[3],"%d",&bincount);
    sscanf(argv[4],"%d",&N);

    //prevents segmentation fault if for some reason there are not N files
    if (argc != (N + 6)){
        printf("Please enter the correct input information.\n");
        printf("It has the follow the follwoing format: \n");
        printf("phistogram minvalue maxvalue bincount N file1 ... fileN outfile\n\n");
        exit(1);
    }
    // define the processid and the variables needed for each file name
    int pid;
    char name [60];
    char *temp;
  
     //run N process
    for (i = 0; i < N; i++)
    {
        pid = fork();
        //run this for child processes
        if (pid == 0)
        {
            
            //determine name for intermediate files
            sprintf(name, "%d", i);
            //strcpy(name, temp);
            
            //run the histogram for this child
            //passes min value, maxvalue, file name of file where to output indermedieate results,
            //file name of file where to read the contets from and the number of bins
            childOperation(minvalue, maxvalue, name, argv[5+i], bincount);
            
            exit(0);

        } else {
            //make sure parent does not close prematurely
            wait(&pid);
        }
        //this line is purely for debugging purposes
        //printf("File name %d is : %s\n", i+1, argv[i+5]);
    }
    
    //open the output file
    FILE  *outputfile = fopen(argv[N+5], "w"); 
    //this line is purely for debugging purposes
    //printf("File name output is : %s\n", argv[N+5]);
    
    //merges the histograms from the intermediate files generated by the N child processes
    //NOTE: This method assumes that the intermediate files are names 0, 1 , 2 ... N-1
    mergeHistograms (bincount,N,outputfile);
    return 0;   
}


//performs the read of one file and builds the histogram by writing result into temporary file
//the function is designed to be run only by one process.
void childOperation(double minvalue, double maxvalue, char *outfile, char* readfile, int bincount)
{
    //declare the needed variables for the computation
    double width;
    int i;
    int histogram[bincount];

    //open the read file
    FILE  *file = fopen(readfile, "r");

    //calculate bin width
    width = (maxvalue - minvalue)/ (double) bincount;

    //make sure that the histogram is initially all 0
    initializeArray (histogram,bincount,0);

    //given the read file, read all the numbers and generate the needed histogram
    getHistogram (file, histogram,minvalue,maxvalue,width);

    //these lines are purely for debugging purposes
   /* for (i = 0; i < bincount; i++) {
        printf (" %d", histogram[i]);
    }
    printf("\n");*/
    
    fclose(file);

    //merge all the intermediate results and write them in the output file
    FILE  *outputfile = fopen(outfile, "w");
       
    writeHistogramToFile(outputfile,histogram,bincount,1);
    
    fclose(outputfile);
}

//initializes int array to a given value
void initializeArray (int *array, int size, int initializer)
{
    int i;
    for (i = 0; i < size; i++)
    {
        array[i] = initializer;
    }
}

//reads a given file in C and populates histogram array
//each number tries to go in the appropriate bin
void getHistogram (FILE *file, int *histogram, double minvalue,double maxvalue, double width)
{
    //define the variables needed for the file read
    double currentNo;
    int index;
    char *line = NULL;
    size_t length = 0;
    ssize_t singleLine;

    // get the number of bins the histogram has.
    int bincount = (int) ((maxvalue - minvalue) /(double) width);

    //read file line by line
    while ((singleLine = getline(&line, &length, file)) != -1) 
    {
        //this line is purely for debugging purposes
        //printf("%s", line);

        //read the float number from file
        currentNo = atof(line);
        //gets the index where the number is found in the histogram
        index = getIndex(minvalue,maxvalue,width,currentNo);

        //this line is purely for debugging purposes
        //printf (" Current index  %d and current no %f  ", index,currentNo);
        
        //deal only with the numbers that are within the given boundaries, ignore everything else
        if (index >= 0 )
        {
            if (index == bincount)
            {
                index = bincount - 1;
            }
            histogram[index] += 1;
        }
     }

    //deallocate the memory
    free(line);
}


//return the index of the histogram for the given number no
int getIndex(double start, double end,  double width, double no)
{
    //check only numebers in the bound [start:end]
    if (no < start || no > end)
    {
        return -1;
    }
    
    return (int) ((no - start) / (double) width);
}

//writes the histogram to a file 
//intermediate bit is only used for internal formating purposes, allowing to write the same
//code for part a and b.
void writeHistogramToFile(FILE *file, int *histogram, int size , int intermediateBit)
{
    int i;
   
    for (i = 0; i <  size; i++)
    {
        if (intermediateBit > 0) 
        {
            fprintf(file, "%d\n", histogram[i]);
            
        } else {
            fprintf(file, "%d:%d\n", i+1, histogram[i]);
        }
    }
}

//merges histogram files into one
//It assumes that the intermediate files are named 0,1,2, ... N-1
void mergeHistograms (int bincount,int N, FILE *outfile)
{
    //define the needed variables
    int i,index=0,currentNo;
    int histogram[bincount];
    ssize_t singleLine;
    size_t length = 0;
    char *line = NULL, *tmp;
    char name[60];
    FILE * file;
    
    //intialize the histogram
    initializeArray(histogram, bincount, 0);

    //process all N intermediate files
    for (i = 0; i < N; i++)
    {
        sprintf(name, "%d", i);
        file = fopen(name, "r");

        //read file line by line
        while ((singleLine = getline(&line, &length, file)) != -1 && index < bincount) 
        {
            currentNo = (int) atof(line); 
            histogram[index] += currentNo;
            index++;
        }
        fclose(file);
        free(line);
        index = 0;

    }

    //write endresult to file
    writeHistogramToFile(outfile, histogram, bincount, 0);
}